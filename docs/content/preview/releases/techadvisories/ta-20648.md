---
title: TA-20648
headerTitle: Index update can be wrongly applied on batch writes
headcontent: 23 Jan 2024
type: docs
showRightNav: true
cascade:
  unversioned: true
menu:
  preview_releases:
    identifier: ta-20648
    weight: 1
rightNav:
  hideH2: true
type: docs
---

|          Product           |  Affected Versions  |  Related Issues   | Fixed In |
| :------------------------- | :------------------ | :---------------- | :------- |
| {{<product "ysql">}}       | {{<release "2.20.x, 2.19.x">}} | {{<issue 20648>}} | {{<release "2.20.1.3, 2.20.2+, 2.21.0">}}      |

## Description

The impacted releases contain an issue where an index update can be wrongly applied, leading to index corruption in the following rare cases:

- Update to a table with non-unique indexes and self-referential triggers where both the index updates, and the trigger application affect the same rows.
- Multi-row update to a table with a non-unique partial index.

## Mitigation

If you're using a {{<release "2.20">}} series release prior to {{<release "2.20.1.3">}}, it is recommended that you upgrade to YugabyteDB {{<release "2.20.1.3">}} or later. The fix ensures new writes to get executed correctly. But it will not repair existing inconsistent data. To fix inconsistent indexes, the indexes need to be recreated. It is advisable to create a new index, and then drop the older one.

## Details

The issue was caused by a combination of two changes: [beeebbe8](https://github.com/yugabyte/yugabyte-db/commit/beeebbe8) and [7b582dd6](https://github.com/yugabyte/yugabyte-db/commit/7b582dd6).

During conflict resolution, intents were collected in a std::map, and then iterating over this map to read conflicts. The change in beeebbe8 altered the conflict resolution process to utilize SeekForward instead of Seek, resulting in more efficient conflict resolution over a sorted set of entries. Additionally, the change introduced the use of a single `value_iter_ for` conflict resolution. When there were entries with different bloom filter keys, the code would not use the bloom filter for the `value_iter_`.

Some write operations used iterators to fetch data from the database, for instance, during an insert operation to check if a row already exists. However, as there was a single write operation per inserted row, each row would create its own iterator. The change in 7b582dd6 added logic to reuse the iterator by operations in the same write batch.

The combination of these two changes, beeebbe8 and 7b582dd6, was causing an issue where bloom filters were prevented from being used during multi-row inserts. Additionally, the change in beeebbe8 introduced a bug with missing conflict, which was fixed by the subsequent change.

In summary, the root cause of the problem was the interaction between the changes in beeebbe8 and 7b582dd6, which prevented the effective use of bloom filters during multi-row inserts, leading to a performance regression and a bug with missing conflict.
